{"ast":null,"code":"const Promise = require('bluebird');\n\nconst EventEmitter = require('events');\n\nconst fs = Promise.promisifyAll(require('fs'));\n\nconst vpk = require('vpk');\n\nconst vdf = require('simple-vdf');\n\nconst hasha = require('hasha');\n\nconst winston = require('winston');\n\nconst defaultConfig = {\n  directory: 'data',\n  updateInterval: 30000,\n  stickers: true,\n  patches: true,\n  graffiti: true,\n  characters: true,\n  musicKits: true,\n  cases: true,\n  tools: true,\n  statusIcons: true,\n  logLevel: 'info'\n};\nconst wears = ['Factory New', 'Minimal Wear', 'Field-Tested', 'Well-Worn', 'Battle-Scarred'];\nconst neededDirectories = {\n  stickers: 'resource/flash/econ/stickers',\n  patches: 'resource/flash/econ/patches',\n  graffiti: 'resource/flash/econ/stickers/default',\n  characters: 'resource/flash/econ/characters',\n  musicKits: 'resource/flash/econ/music_kits',\n  cases: 'resource/flash/econ/weapon_cases',\n  tools: 'resource/flash/econ/tools',\n  statusIcons: 'resource/flash/econ/status_icons'\n};\n\nfunction bytesToMB(bytes) {\n  return (bytes / 1000000).toFixed(2);\n}\n\nclass CSGOCdn extends EventEmitter {\n  get ready() {\n    return this.ready_ || false;\n  }\n\n  get steamReady() {\n    return !!this.user.steamID;\n  }\n\n  get phase() {\n    return {\n      ruby: 'am_ruby_marbleized',\n      sapphire: 'am_sapphire_marbleized',\n      blackpearl: 'am_blackpearl_marbleized',\n      emerald: 'am_emerald_marbleized',\n      phase1: 'phase1',\n      phase2: 'phase2',\n      phase3: 'phase3',\n      phase4: 'phase4'\n    };\n  }\n\n  set ready(r) {\n    const old = this.ready;\n    this.ready_ = r;\n\n    if (r !== old && r) {\n      this.log.debug('Ready');\n      this.emit('ready');\n    }\n  }\n\n  constructor(steamUser) {\n    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.config = Object.assign(defaultConfig, config);\n    this.createDataDirectory();\n    this.user = Promise.promisifyAll(steamUser, {\n      multiArgs: true\n    });\n    this.log = winston.createLogger({\n      level: config.logLevel,\n      transports: [new winston.transports.Console({\n        colorize: true,\n        format: winston.format.printf(info => {\n          return `[csgo-image-cdn] ${info.level}: ${info.message}`;\n        })\n      })]\n    });\n\n    if (!this.steamReady) {\n      this.log.debug('Steam not ready, waiting for logon');\n      this.user.once('loggedOn', () => {\n        this.updateLoop();\n      });\n    } else {\n      this.updateLoop();\n    }\n  }\n  /**\r\n   * Creates the data directory specified in the config if it doesn't exist\r\n   */\n\n\n  createDataDirectory() {\n    const dir = `./${this.config.directory}`;\n\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir);\n    }\n  }\n  /**\r\n   * Runs the update loop at the specified config interval\r\n   * @return {Promise<undefined>|void}\r\n   */\n\n\n  updateLoop() {\n    if (this.config.updateInterval > 0) {\n      return this.update().then(() => Promise.delay(this.config.updateInterval * 1000)).then(() => this.updateLoop());\n    } else {\n      this.log.info('Auto-updates disabled, checking if required files exist'); // Try to load the resources locally\n\n      try {\n        this.loadResources();\n        this.loadVPK();\n        this.ready = true;\n      } catch (e) {\n        this.log.warn('Needed CS:GO files not installed');\n        this.update();\n      }\n    }\n  }\n  /**\r\n   * Returns the product info for CSGO, with its depots and packages\r\n   */\n\n\n  getProductInfo() {\n    this.log.debug('Obtaining CS:GO product info');\n    return new Promise((resolve, reject) => {\n      this.user.getProductInfo([730], [], true, (apps, packages, unknownApps, unknownPackages) => {\n        resolve([apps, packages, unknownApps, unknownPackages]);\n      });\n    });\n  }\n  /**\r\n   * Returns the latest CSGO manifest ID for the public 731 depot\r\n   * @return {*|PromiseLike<*[]>|Promise<*[]>} 731 Depot Manifest ID\r\n   */\n\n\n  getLatestManifestId() {\n    this.log.debug('Obtaining latest manifest ID');\n    return this.getProductInfo().then(_ref => {\n      let [apps, packages, unknownApps, unknownPackages] = _ref;\n      const csgo = packages['730'].appinfo;\n      const commonDepot = csgo.depots['731'];\n      return commonDepot.manifests.public;\n    });\n  }\n  /**\r\n   * Retrieves and updates the sticker file directory from Valve\r\n   *\r\n   * Ensures that only the required VPK files are downloaded and that files with the same SHA1 aren't\r\n   * redownloaded\r\n   *\r\n   * @return {Promise<void>}\r\n   */\n\n\n  async update() {\n    this.log.info('Checking for CS:GO file updates');\n\n    if (!this.steamReady) {\n      this.log.warn(`Steam not ready, can't check for updates`);\n      return;\n    }\n\n    const manifestId = await this.getLatestManifestId();\n    this.log.debug(`Obtained latest manifest ID: ${manifestId}`);\n    const [manifest] = await this.user.getManifestAsync(730, 731, manifestId);\n    const manifestFiles = manifest.files;\n    const dirFile = manifest.files.find(file => file.filename.endsWith(\"csgo\\\\pak01_dir.vpk\"));\n    const itemsGameFile = manifest.files.find(file => file.filename.endsWith(\"items_game.txt\"));\n    const itemsGameCDNFile = manifest.files.find(file => file.filename.endsWith(\"items_game_cdn.txt\"));\n    const csgoEnglishFile = manifest.files.find(file => file.filename.endsWith(\"csgo_english.txt\"));\n    this.log.debug(`Downloading required static files`);\n    await this.downloadFiles([dirFile, itemsGameFile, itemsGameCDNFile, csgoEnglishFile]);\n    this.log.debug('Loading static file resources');\n    this.loadResources();\n    this.loadVPK();\n    await this.downloadVPKFiles(this.vpkDir, manifestFiles);\n    this.ready = true;\n  }\n\n  loadResources() {\n    this.itemsGame = vdf.parse(fs.readFileSync(`${this.config.directory}/items_game.txt`, 'utf8'))['items_game'];\n    this.csgoEnglish = vdf.parse(fs.readFileSync(`${this.config.directory}/csgo_english.txt`, 'ucs2'))['lang']['Tokens'];\n    this.itemsGameCDN = this.parseItemsCDN(fs.readFileSync(`${this.config.directory}/items_game_cdn.txt`, 'utf8'));\n    this.weaponNameMap = Object.keys(this.csgoEnglish).filter(n => n.startsWith(\"SFUI_WPNHUD\"));\n    this.csgoEnglishKeys = Object.keys(this.csgoEnglish); // Ensure paint kit descriptions are lowercase to resolve inconsistencies in the language and items_game file\n\n    Object.keys(this.itemsGame.paint_kits).forEach(n => {\n      const kit = this.itemsGame.paint_kits[n];\n\n      if ('description_tag' in kit) {\n        kit.description_tag = kit.description_tag.toLowerCase();\n      }\n    });\n    this.invertDictionary(this.csgoEnglish);\n  }\n  /**\r\n   * Inverts the key mapping of a dictionary recursively while preserving the original keys\r\n   *\r\n   * Duplicate values with be an array\r\n   *\r\n   * @param dict Dictionary to invert\r\n   */\n\n\n  invertDictionary(dict) {\n    dict['inverted'] = {};\n\n    for (const prop in dict) {\n      if (prop === 'inverted' || !dict.hasOwnProperty(prop)) continue;\n      const val = dict[prop];\n\n      if (typeof val === 'object' && !(val instanceof Array)) {\n        this.invertDictionary(val);\n      } else {\n        if (dict['inverted'][val] === undefined) {\n          dict['inverted'][val] = [prop];\n        } else {\n          dict['inverted'][val].push(prop);\n        }\n      }\n    }\n  }\n\n  parseItemsCDN(data) {\n    let lines = data.split('\\n');\n    const items_game_cdn = {};\n\n    for (let line of lines) {\n      let kv = line.split('=');\n\n      if (kv[1]) {\n        items_game_cdn[kv[0]] = kv[1];\n      }\n    }\n\n    return items_game_cdn;\n  }\n  /**\r\n   * Downloads the given VPK files from the Steam CDN\r\n   * @param files Steam Manifest File Array\r\n   * @return {Promise<>} Fulfilled when completed downloading\r\n   */\n\n\n  async downloadFiles(files) {\n    const promises = [];\n\n    for (const file of files) {\n      let name = file.filename.split('\\\\');\n      name = name[name.length - 1];\n      const path = `${this.config.directory}/${name}`;\n      const isDownloaded = await this.isFileDownloaded(path, file.sha_content);\n\n      if (isDownloaded) {\n        continue;\n      }\n\n      const promise = this.user.downloadFile(730, 731, file, `${this.config.directory}/${name}`);\n      promises.push(promise);\n    }\n\n    return Promise.all(promises);\n  }\n  /**\r\n   * Loads the CSGO dir VPK specified in the config\r\n   */\n\n\n  loadVPK() {\n    this.vpkDir = new vpk(this.config.directory + '/pak01_dir.vpk');\n    this.vpkDir.load();\n    this.vpkStickerFiles = this.vpkDir.files.filter(f => f.startsWith('resource/flash/econ/stickers'));\n    this.vpkPatchFiles = this.vpkDir.files.filter(f => f.startsWith('resource/flash/econ/patches'));\n  }\n  /**\r\n   * Given the CSGO VPK Directory, returns the necessary indices for the chosen options\r\n   * @param vpkDir CSGO VPK Directory\r\n   * @return {Array} Necessary Sticker VPK Indices\r\n   */\n\n\n  getRequiredVPKFiles(vpkDir) {\n    const requiredIndices = [];\n    const neededDirs = Object.keys(neededDirectories).filter(f => !!this.config[f]).map(f => neededDirectories[f]);\n\n    for (const fileName of vpkDir.files) {\n      for (const dir of neededDirs) {\n        if (fileName.startsWith(dir)) {\n          const archiveIndex = vpkDir.tree[fileName].archiveIndex;\n\n          if (!requiredIndices.includes(archiveIndex)) {\n            requiredIndices.push(archiveIndex);\n          }\n\n          break;\n        }\n      }\n    }\n\n    return requiredIndices.sort();\n  }\n  /**\r\n   * Downloads the required VPK files\r\n   * @param vpkDir CSGO VPK Directory\r\n   * @param manifestFiles Manifest files\r\n   * @return {Promise<void>}\r\n   */\n\n\n  async downloadVPKFiles(vpkDir, manifestFiles) {\n    this.log.debug('Computing required VPK files for selected packages');\n    const requiredIndices = this.getRequiredVPKFiles(vpkDir);\n    this.log.debug(`Required VPK files ${requiredIndices}`);\n\n    for (let index in requiredIndices) {\n      index = parseInt(index); // pad to 3 zeroes\n\n      const archiveIndex = requiredIndices[index];\n      const paddedIndex = '0'.repeat(3 - archiveIndex.toString().length) + archiveIndex;\n      const fileName = `pak01_${paddedIndex}.vpk`;\n      const file = manifestFiles.find(f => f.filename.endsWith(fileName));\n      const filePath = `${this.config.directory}/${fileName}`;\n      const isDownloaded = await this.isFileDownloaded(filePath, file.sha_content);\n\n      if (isDownloaded) {\n        this.log.info(`Already downloaded ${filePath}`);\n        continue;\n      }\n\n      const status = `[${index + 1}/${requiredIndices.length}]`;\n      this.log.info(`${status} Downloading ${fileName} - ${bytesToMB(file.size)} MB`);\n      await this.user.downloadFile(730, 731, file, filePath, (none, _ref2) => {\n        let {\n          type,\n          bytesDownloaded,\n          totalSizeBytes\n        } = _ref2;\n\n        if (type === 'progress') {\n          this.log.info(`${status} ${(bytesDownloaded * 100 / totalSizeBytes).toFixed(2)}% - ${bytesToMB(bytesDownloaded)}/${bytesToMB(totalSizeBytes)} MB`);\n        }\n      });\n      this.log.info(`${status} Downloaded ${fileName}`);\n    }\n  }\n  /**\r\n   * Returns whether a file at the given path has the given sha1\r\n   * @param path File path\r\n   * @param sha1 File SHA1 hash\r\n   * @return {Promise<boolean>} Whether the file has the hash\r\n   */\n\n\n  async isFileDownloaded(path, sha1) {\n    try {\n      const hash = await hasha.fromFile(path, {\n        algorithm: 'sha1'\n      });\n      return hash === sha1;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\r\n   * Given a VPK path, returns the CDN URL\r\n   * @param path VPK path\r\n   * @return {string|void} CDN URL\r\n   */\n\n\n  getPathURL(path) {\n    const file = this.vpkDir.getFile(path);\n\n    if (!file) {\n      this.log.error(`Failed to retrieve ${path} in VPK, do you have the package category enabled in options?`);\n      return;\n    }\n\n    const sha1 = hasha(file, {\n      'algorithm': 'sha1'\n    });\n    path = path.replace('resource/flash', 'icons');\n    path = path.replace('.png', `.${sha1}.png`);\n    return `https://steamcdn-a.akamaihd.net/apps/730/${path}`;\n  }\n  /**\r\n   * Returns the item Steam CDN URL for the specified name\r\n   *\r\n   * Example Sticker Names: cologne2016/nv, cologne2016/fntc_holo, cologne2016/fntc_foil, cluj2015/sig_olofmeister_gold\r\n   *\r\n   * You can find the sticker names from their relevant \"sticker_material\" fields in items_game.txt\r\n   *      items_game.txt can be found in the core game files of CS:GO or as itemsGame here\r\n   *\r\n   * @param name The item name (the sticker_material field in items_game.txt, or the cdn file format)\r\n   * @param large Whether to obtain the \"large\" CDN version of the item\r\n   * @return {string|void} If successful, the HTTPS CDN URL for the item\r\n   */\n\n\n  getStickerURL(name) {\n    let large = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (!this.ready) {\n      return;\n    }\n\n    const fileName = large ? `${name}_large.png` : `${name}.png`;\n    const path = this.vpkStickerFiles.find(t => t.endsWith(fileName));\n    if (path) return this.getPathURL(path);\n  }\n  /**\r\n   * Returns the item Steam CDN URL for the specified name\r\n   *\r\n   * Example Patch Names: case01/patch_phoenix, case01/patch_dangerzone, case01/patch_easypeasy, case_skillgroups/patch_goldnova1\r\n   *\r\n   * You can find the patch names from their relevant \"patch_material\" fields in items_game.txt\r\n   *      items_game.txt can be found in the core game files of CS:GO or as itemsGame here\r\n   *\r\n   * @param name The item name (the patch_material field in items_game.txt, or the cdn file format)\r\n   * @param large Whether to obtain the \"large\" CDN version of the item\r\n   * @return {string|void} If successful, the HTTPS CDN URL for the item\r\n   */\n\n\n  getPatchURL(name) {\n    let large = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (!this.ready) {\n      return;\n    }\n\n    const fileName = large ? `${name}_large.png` : `${name}.png`;\n    const path = this.vpkPatchFiles.find(t => t.endsWith(fileName));\n    if (path) return this.getPathURL(path);\n  }\n  /**\r\n   * Given the specified defindex and paintindex, returns the CDN URL\r\n   *\r\n   * The item properties can be found in items_game.txt\r\n   *\r\n   * @param defindex Item Definition Index (weapon type)\r\n   * @param paintindex Item Paint Index (skin type)\r\n   * @return {string|void} Weapon CDN URL\r\n   */\n\n\n  getWeaponURL(defindex, paintindex) {\n    if (!this.ready) return;\n    const paintKits = this.itemsGame.paint_kits; // Get the skin name\n\n    let skinName = '';\n\n    if (paintindex in paintKits) {\n      skinName = paintKits[paintindex].name;\n\n      if (skinName === 'default') {\n        skinName = '';\n      }\n    } // Get the weapon name\n\n\n    let weaponName;\n    const items = this.itemsGame.items;\n\n    if (defindex in items) {\n      weaponName = items[defindex].name;\n    } // Get the image url\n\n\n    const cdnName = `${weaponName}_${skinName}`;\n    return this.itemsGameCDN[cdnName];\n  }\n  /**\r\n   * Returns whether the given name is a weapon by checking\r\n   * the prefab and whether it is used by one of the sides\r\n   * @param marketHashName Item name\r\n   * @return {boolean} Whether a weapon\r\n   */\n\n\n  isWeapon(marketHashName) {\n    const prefabs = this.itemsGame.prefabs;\n    const items = this.itemsGame.items;\n    const weaponName = marketHashName.split('|')[0].trim();\n    const weaponTags = this.csgoEnglish['inverted'][weaponName];\n    if (!weaponTags) return false; // For every matching weapon tag...\n\n    for (const t of weaponTags) {\n      const weaponTag = `#${t}`;\n      const prefab = Object.keys(prefabs).find(n => {\n        const fab = prefabs[n];\n        return fab.item_name === weaponTag;\n      });\n      let fab;\n\n      if (!prefab) {\n        // special knives aren't in the prefab (karambits, etc...)\n        const item = Object.keys(items).find(n => {\n          const i = items[n];\n          return i.item_name === weaponTag;\n        });\n        fab = items[item];\n      } else {\n        fab = prefabs[prefab];\n      }\n\n      if (fab && fab.used_by_classes) {\n        const used = fab.used_by_classes; // Ensure that the item is used by one of the sides\n\n        if (used['terrorists'] || used['counter-terrorists']) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\r\n   * Returns the sticker URL given the market hash name\r\n   * @param marketHashName Sticker name\r\n   * @return {string|void} Sticker image URL\r\n   */\n\n\n  getStickerNameURL(marketHashName) {\n    const reg = /Sticker \\| (.*)/;\n    const match = marketHashName.match(reg);\n    if (!match) return;\n    const stickerName = match[1];\n\n    for (const tag of this.csgoEnglish['inverted'][stickerName] || []) {\n      const stickerTag = `#${tag}`;\n      const stickerKits = this.itemsGame.sticker_kits;\n      const kitIndex = Object.keys(stickerKits).find(n => {\n        const k = stickerKits[n];\n        return k.item_name === stickerTag;\n      });\n      const kit = stickerKits[kitIndex];\n      if (!kit || !kit.sticker_material) continue;\n      const url = this.getStickerURL(stickerKits[kitIndex].sticker_material, true);\n\n      if (url) {\n        return url;\n      }\n    }\n  }\n  /**\r\n   * Returns the patch URL given the market hash name\r\n   * @param marketHashName Patch name\r\n   * @return {string|void} Patch image URL\r\n   */\n\n\n  getPatchNameURL(marketHashName) {\n    const reg = /Patch \\| (.*)/;\n    const match = marketHashName.match(reg);\n    if (!match) return;\n    const stickerName = match[1];\n\n    for (const tag of this.csgoEnglish['inverted'][stickerName] || []) {\n      const stickerTag = `#${tag}`;\n      const stickerKits = this.itemsGame.sticker_kits; // Patches are in the sticker_kits as well\n\n      const kitIndex = Object.keys(stickerKits).find(n => {\n        const k = stickerKits[n];\n        return k.item_name === stickerTag;\n      });\n      const kit = stickerKits[kitIndex];\n      if (!kit || !kit.patch_material) continue;\n      const url = this.getPatchURL(stickerKits[kitIndex].patch_material, true);\n      if (url) return url;\n    }\n  }\n  /**\r\n   * Returns the graffiti URL given the market hash name\r\n   * @param marketHashName Graffiti name (optional tint)\r\n   * @param large Whether to obtain the \"large\" CDN version of the item\r\n   * @return {string|void} CDN Image URL\r\n   */\n\n\n  getGraffitiNameURL(marketHashName) {\n    let large = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const reg = /Sealed Graffiti \\| ([^(]*)/;\n    const match = marketHashName.match(reg);\n    if (!match) return;\n    const graffitiName = match[1].trim();\n\n    for (const tag of this.csgoEnglish['inverted'][graffitiName] || []) {\n      const stickerTag = `#${tag}`;\n      const stickerKits = this.itemsGame.sticker_kits;\n      const kitIndices = Object.keys(stickerKits).filter(n => {\n        const k = stickerKits[n];\n        return k.item_name === stickerTag;\n      }); // prefer kit indices with \"graffiti\" in the name\n\n      kitIndices.sort((a, b) => {\n        const index1 = !!stickerKits[a].name && stickerKits[a].name.indexOf('graffiti');\n        const index2 = !!stickerKits[b].name && stickerKits[b].name.indexOf('graffiti');\n\n        if (index1 === index2) {\n          return 0;\n        } else if (index1 > -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      });\n\n      for (const kitIndex of kitIndices) {\n        const kit = stickerKits[kitIndex];\n        if (!kit || !kit.sticker_material) continue;\n        const url = this.getStickerURL(kit.sticker_material, true);\n\n        if (url) {\n          return url;\n        }\n      }\n    }\n  }\n  /**\r\n   * Returns the weapon URL given the market hash name\r\n   * @param marketHashName Weapon name\r\n   * @param {string?} phase Optional Doppler Phase from the phase enum\r\n   * @return {string|void} Weapon image URL\r\n   */\n\n\n  getWeaponNameURL(marketHashName, phase) {\n    const hasWear = wears.findIndex(n => marketHashName.includes(n)) > -1;\n\n    if (hasWear) {\n      // remove it\n      marketHashName = marketHashName.replace(/\\([^)]*\\)$/, '');\n    }\n\n    const match = marketHashName.split('|').map(m => m.trim());\n    const weaponName = match[0];\n    const skinName = match[1];\n    if (!weaponName) return;\n    const weaponTags = this.csgoEnglish['inverted'][weaponName] || [];\n    const prefabs = this.itemsGame.prefabs;\n    const items = this.itemsGame.items; // For every matching weapon tag...\n\n    for (const t of weaponTags) {\n      const weaponTag = `#${t}`;\n      const prefab = Object.keys(prefabs).find(n => {\n        const fab = prefabs[n];\n        return fab.item_name === weaponTag;\n      });\n      let weaponClass;\n\n      if (!prefab) {\n        // special knives aren't in the prefab (karambits, etc...)\n        const item = Object.keys(items).find(n => {\n          const i = items[n];\n          return i.item_name === weaponTag;\n        });\n\n        if (items[item]) {\n          weaponClass = items[item].name;\n        }\n      } else {\n        const item = Object.keys(items).find(n => {\n          const i = items[n];\n          return i.prefab === prefab;\n        });\n\n        if (items[item]) {\n          weaponClass = items[item].name;\n        }\n      }\n\n      if (!weaponClass) continue; // Check if this is a vanilla weapon\n\n      if (!skinName) {\n        if (weaponClass && this.itemsGameCDN[weaponClass]) {\n          return this.itemsGameCDN[weaponClass];\n        } else {\n          continue;\n        }\n      } // For every matching skin name...\n\n\n      for (const key of this.csgoEnglish['inverted'][skinName] || []) {\n        const skinTag = `#${key.toLowerCase()}`;\n        const paintKits = this.itemsGame.paint_kits;\n        const paintindexes = Object.keys(paintKits).filter(n => {\n          const kit = paintKits[n];\n          const isPhase = !phase || kit.name.endsWith(phase);\n          return isPhase && kit.description_tag === skinTag;\n        }); // For every matching paint index...\n\n        for (const paintindex of paintindexes) {\n          const paintKit = paintKits[paintindex].name;\n          const path = (paintKit ? `${weaponClass}_${paintKit}` : weaponClass).toLowerCase();\n\n          if (this.itemsGameCDN[path]) {\n            return this.itemsGameCDN[path];\n          }\n        }\n      }\n    }\n  }\n  /**\r\n   * Returns the music kit URL given the market hash name\r\n   * @param marketHashName Music kit name\r\n   * @return {string|void} Music kit image URL\r\n   */\n\n\n  getMusicKitNameURL(marketHashName) {\n    const reg = /Music Kit \\| (.*)/;\n    const match = marketHashName.match(reg);\n    if (!match) return;\n    const kitName = match[1];\n\n    for (const t of this.csgoEnglish['inverted'][kitName] || []) {\n      const tag = `#${t}`;\n      const musicDefs = this.itemsGame.music_definitions;\n      const kitIndex = Object.keys(musicDefs).find(n => {\n        const k = musicDefs[n];\n        return k.loc_name === tag;\n      });\n      const kit = musicDefs[kitIndex];\n      if (!kit || !kit.image_inventory) continue;\n      const path = `resource/flash/${kit.image_inventory}.png`;\n      const url = this.getPathURL(path);\n\n      if (url) {\n        return url;\n      }\n    }\n  }\n  /**\r\n   * Retrieves the given item CDN URL given its market_hash_name\r\n   *\r\n   * Examples: M4A4 | 龍王 (Dragon King) (Field-Tested), Sticker | Robo, AWP | Redline (Field-Tested)\r\n   *\r\n   * Note: For a weapon, the name MUST have the associated wear\r\n   *\r\n   * @param marketHashName Item name\r\n   * @param {string?} phase Optional Doppler Phase from the phase enum\r\n   */\n\n\n  getItemNameURL(marketHashName, phase) {\n    marketHashName = marketHashName.trim();\n    let strippedMarketHashName = marketHashName; // Weapons and Music Kits can have extra tags we need to ignore\n\n    const extraTags = ['★ ', 'StatTrak™ ', 'Souvenir '];\n\n    for (const tag of extraTags) {\n      if (strippedMarketHashName.startsWith(tag)) {\n        strippedMarketHashName = strippedMarketHashName.replace(tag, '');\n      }\n    }\n\n    if (this.isWeapon(strippedMarketHashName)) {\n      return this.getWeaponNameURL(strippedMarketHashName, phase);\n    } else if (strippedMarketHashName.startsWith('Music Kit |')) {\n      return this.getMusicKitNameURL(strippedMarketHashName);\n    } else if (marketHashName.startsWith('Sticker |')) {\n      return this.getStickerNameURL(marketHashName);\n    } else if (marketHashName.startsWith('Sealed Graffiti |')) {\n      return this.getGraffitiNameURL(marketHashName);\n    } else if (marketHashName.startsWith('Patch |')) {\n      return this.getPatchNameURL(marketHashName);\n    } else {\n      // Other in items\n      for (const t of this.csgoEnglish['inverted'][marketHashName] || []) {\n        const tag = `#${t.toLowerCase()}`;\n        const items = this.itemsGame.items;\n        const prefabs = this.itemsGame.prefabs;\n        let item = Object.keys(items).find(n => {\n          const i = items[n];\n          return i.item_name && i.item_name.toLowerCase() === tag;\n        });\n        let path;\n\n        if (!items[item] || !items[item].image_inventory) {\n          // search the prefabs (ex. CS:GO Case Key)\n          item = Object.keys(prefabs).find(n => {\n            const i = prefabs[n];\n            return i.item_name && i.item_name.toLowerCase() === tag;\n          });\n          if (!prefabs[item] || !prefabs[item].image_inventory) continue;\n          path = `resource/flash/${prefabs[item].image_inventory}.png`;\n        } else {\n          path = `resource/flash/${items[item].image_inventory}.png`;\n        }\n\n        const url = this.getPathURL(path);\n\n        if (url) {\n          return url;\n        }\n      }\n    }\n  }\n\n}\n\nmodule.exports = CSGOCdn;","map":{"version":3,"names":["Promise","require","EventEmitter","fs","promisifyAll","vpk","vdf","hasha","winston","defaultConfig","directory","updateInterval","stickers","patches","graffiti","characters","musicKits","cases","tools","statusIcons","logLevel","wears","neededDirectories","bytesToMB","bytes","toFixed","CSGOCdn","ready","ready_","steamReady","user","steamID","phase","ruby","sapphire","blackpearl","emerald","phase1","phase2","phase3","phase4","r","old","log","debug","emit","constructor","steamUser","config","Object","assign","createDataDirectory","multiArgs","createLogger","level","transports","Console","colorize","format","printf","info","message","once","updateLoop","dir","existsSync","mkdirSync","update","then","delay","loadResources","loadVPK","e","warn","getProductInfo","resolve","reject","apps","packages","unknownApps","unknownPackages","getLatestManifestId","csgo","appinfo","commonDepot","depots","manifests","public","manifestId","manifest","getManifestAsync","manifestFiles","files","dirFile","find","file","filename","endsWith","itemsGameFile","itemsGameCDNFile","csgoEnglishFile","downloadFiles","downloadVPKFiles","vpkDir","itemsGame","parse","readFileSync","csgoEnglish","itemsGameCDN","parseItemsCDN","weaponNameMap","keys","filter","n","startsWith","csgoEnglishKeys","paint_kits","forEach","kit","description_tag","toLowerCase","invertDictionary","dict","prop","hasOwnProperty","val","Array","undefined","push","data","lines","split","items_game_cdn","line","kv","promises","name","length","path","isDownloaded","isFileDownloaded","sha_content","promise","downloadFile","all","load","vpkStickerFiles","f","vpkPatchFiles","getRequiredVPKFiles","requiredIndices","neededDirs","map","fileName","archiveIndex","tree","includes","sort","index","parseInt","paddedIndex","repeat","toString","filePath","status","size","none","type","bytesDownloaded","totalSizeBytes","sha1","hash","fromFile","algorithm","getPathURL","getFile","error","replace","getStickerURL","large","t","getPatchURL","getWeaponURL","defindex","paintindex","paintKits","skinName","weaponName","items","cdnName","isWeapon","marketHashName","prefabs","trim","weaponTags","weaponTag","prefab","fab","item_name","item","i","used_by_classes","used","getStickerNameURL","reg","match","stickerName","tag","stickerTag","stickerKits","sticker_kits","kitIndex","k","sticker_material","url","getPatchNameURL","patch_material","getGraffitiNameURL","graffitiName","kitIndices","a","b","index1","indexOf","index2","getWeaponNameURL","hasWear","findIndex","m","weaponClass","key","skinTag","paintindexes","isPhase","paintKit","getMusicKitNameURL","kitName","musicDefs","music_definitions","loc_name","image_inventory","getItemNameURL","strippedMarketHashName","extraTags","module","exports"],"sources":["/home/daniil/github/steamApp/node_modules/csgo-cdn/index.js"],"sourcesContent":["const Promise = require('bluebird');\r\nconst EventEmitter = require('events');\r\nconst fs = Promise.promisifyAll(require('fs'));\r\nconst vpk = require('vpk');\r\nconst vdf = require('simple-vdf');\r\nconst hasha = require('hasha');\r\nconst winston = require('winston');\r\n\r\nconst defaultConfig = {\r\n    directory: 'data',\r\n    updateInterval: 30000,\r\n    stickers: true,\r\n    patches: true,\r\n    graffiti: true,\r\n    characters: true,\r\n    musicKits: true,\r\n    cases: true,\r\n    tools: true,\r\n    statusIcons: true,\r\n    logLevel: 'info'\r\n};\r\n\r\nconst wears = ['Factory New', 'Minimal Wear', 'Field-Tested', 'Well-Worn', 'Battle-Scarred'];\r\n\r\nconst neededDirectories = {\r\n    stickers: 'resource/flash/econ/stickers',\r\n    patches: 'resource/flash/econ/patches',\r\n    graffiti: 'resource/flash/econ/stickers/default',\r\n    characters: 'resource/flash/econ/characters',\r\n    musicKits: 'resource/flash/econ/music_kits',\r\n    cases: 'resource/flash/econ/weapon_cases',\r\n    tools: 'resource/flash/econ/tools',\r\n    statusIcons: 'resource/flash/econ/status_icons',\r\n};\r\n\r\nfunction bytesToMB(bytes) {\r\n    return (bytes/1000000).toFixed(2);\r\n}\r\n\r\nclass CSGOCdn extends EventEmitter {\r\n    get ready() {\r\n        return this.ready_ || false;\r\n    }\r\n\r\n    get steamReady() {\r\n        return !!this.user.steamID;\r\n    }\r\n\r\n    get phase() {\r\n        return {\r\n            ruby: 'am_ruby_marbleized',\r\n            sapphire: 'am_sapphire_marbleized',\r\n            blackpearl: 'am_blackpearl_marbleized',\r\n            emerald: 'am_emerald_marbleized',\r\n            phase1: 'phase1',\r\n            phase2: 'phase2',\r\n            phase3: 'phase3',\r\n            phase4: 'phase4'\r\n        }\r\n    }\r\n\r\n    set ready(r) {\r\n        const old = this.ready;\r\n        this.ready_ = r;\r\n\r\n        if (r !== old && r) {\r\n            this.log.debug('Ready');\r\n            this.emit('ready');\r\n        }\r\n    }\r\n\r\n    constructor(steamUser, config={}) {\r\n        super();\r\n\r\n        this.config = Object.assign(defaultConfig, config);\r\n\r\n        this.createDataDirectory();\r\n\r\n        this.user = Promise.promisifyAll(steamUser, {multiArgs: true});\r\n\r\n        this.log = winston.createLogger({\r\n            level: config.logLevel,\r\n            transports: [\r\n                new winston.transports.Console({\r\n                    colorize: true,\r\n                    format: winston.format.printf((info) => {\r\n                        return `[csgo-image-cdn] ${info.level}: ${info.message}`;\r\n                    })\r\n                })\r\n            ]\r\n        });\r\n\r\n        if (!this.steamReady) {\r\n            this.log.debug('Steam not ready, waiting for logon');\r\n\r\n            this.user.once('loggedOn', () => {\r\n                this.updateLoop();\r\n            });\r\n        }\r\n        else {\r\n            this.updateLoop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates the data directory specified in the config if it doesn't exist\r\n     */\r\n    createDataDirectory() {\r\n        const dir = `./${this.config.directory}`;\r\n\r\n        if (!fs.existsSync(dir)){\r\n            fs.mkdirSync(dir);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs the update loop at the specified config interval\r\n     * @return {Promise<undefined>|void}\r\n     */\r\n    updateLoop() {\r\n        if (this.config.updateInterval > 0) {\r\n            return this.update().then(() => Promise.delay(this.config.updateInterval*1000))\r\n                .then(() => this.updateLoop());\r\n        }\r\n        else {\r\n            this.log.info('Auto-updates disabled, checking if required files exist');\r\n\r\n            // Try to load the resources locally\r\n            try {\r\n                this.loadResources();\r\n                this.loadVPK();\r\n                this.ready = true;\r\n            } catch(e) {\r\n                this.log.warn('Needed CS:GO files not installed');\r\n                this.update();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the product info for CSGO, with its depots and packages\r\n     */\r\n    getProductInfo() {\r\n        this.log.debug('Obtaining CS:GO product info');\r\n        return new Promise((resolve, reject) => {\r\n            this.user.getProductInfo([730], [], true, (apps, packages, unknownApps, unknownPackages) => {\r\n                resolve([apps, packages, unknownApps, unknownPackages]);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the latest CSGO manifest ID for the public 731 depot\r\n     * @return {*|PromiseLike<*[]>|Promise<*[]>} 731 Depot Manifest ID\r\n     */\r\n    getLatestManifestId() {\r\n        this.log.debug('Obtaining latest manifest ID');\r\n        return this.getProductInfo().then(([apps, packages, unknownApps, unknownPackages]) => {\r\n            const csgo = packages['730'].appinfo;\r\n            const commonDepot = csgo.depots['731'];\r\n\r\n            return commonDepot.manifests.public;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Retrieves and updates the sticker file directory from Valve\r\n     *\r\n     * Ensures that only the required VPK files are downloaded and that files with the same SHA1 aren't\r\n     * redownloaded\r\n     *\r\n     * @return {Promise<void>}\r\n     */\r\n    async update() {\r\n        this.log.info('Checking for CS:GO file updates');\r\n\r\n        if (!this.steamReady) {\r\n            this.log.warn(`Steam not ready, can't check for updates`);\r\n            return;\r\n        }\r\n\r\n        const manifestId = await this.getLatestManifestId();\r\n\r\n        this.log.debug(`Obtained latest manifest ID: ${manifestId}`);\r\n\r\n        const [manifest] = await this.user.getManifestAsync(730, 731, manifestId);\r\n        const manifestFiles = manifest.files;\r\n\r\n        const dirFile = manifest.files.find((file) => file.filename.endsWith(\"csgo\\\\pak01_dir.vpk\"));\r\n        const itemsGameFile = manifest.files.find((file) => file.filename.endsWith(\"items_game.txt\"));\r\n        const itemsGameCDNFile = manifest.files.find((file) => file.filename.endsWith(\"items_game_cdn.txt\"));\r\n        const csgoEnglishFile = manifest.files.find((file) => file.filename.endsWith(\"csgo_english.txt\"));\r\n\r\n        this.log.debug(`Downloading required static files`);\r\n\r\n        await this.downloadFiles([dirFile, itemsGameFile, itemsGameCDNFile, csgoEnglishFile]);\r\n\r\n        this.log.debug('Loading static file resources');\r\n\r\n        this.loadResources();\r\n        this.loadVPK();\r\n\r\n        await this.downloadVPKFiles(this.vpkDir, manifestFiles);\r\n\r\n        this.ready = true;\r\n    }\r\n\r\n    loadResources() {\r\n        this.itemsGame = vdf.parse(fs.readFileSync(`${this.config.directory}/items_game.txt`, 'utf8'))['items_game'];\r\n        this.csgoEnglish = vdf.parse(fs.readFileSync(`${this.config.directory}/csgo_english.txt`, 'ucs2'))['lang']['Tokens'];\r\n        this.itemsGameCDN = this.parseItemsCDN(fs.readFileSync(`${this.config.directory}/items_game_cdn.txt`, 'utf8'));\r\n\r\n        this.weaponNameMap = Object.keys(this.csgoEnglish).filter(n => n.startsWith(\"SFUI_WPNHUD\"));\r\n        this.csgoEnglishKeys = Object.keys(this.csgoEnglish);\r\n\r\n        // Ensure paint kit descriptions are lowercase to resolve inconsistencies in the language and items_game file\r\n        Object.keys(this.itemsGame.paint_kits).forEach((n) => {\r\n            const kit = this.itemsGame.paint_kits[n];\r\n\r\n            if ('description_tag' in kit) {\r\n                kit.description_tag = kit.description_tag.toLowerCase();\r\n            }\r\n        });\r\n\r\n        this.invertDictionary(this.csgoEnglish);\r\n    }\r\n\r\n    /**\r\n     * Inverts the key mapping of a dictionary recursively while preserving the original keys\r\n     *\r\n     * Duplicate values with be an array\r\n     *\r\n     * @param dict Dictionary to invert\r\n     */\r\n    invertDictionary(dict) {\r\n        dict['inverted'] = {};\r\n\r\n        for (const prop in dict) {\r\n            if (prop === 'inverted' || !dict.hasOwnProperty(prop)) continue;\r\n\r\n            const val = dict[prop];\r\n\r\n            if (typeof val === 'object' && !(val instanceof Array)) {\r\n                this.invertDictionary(val);\r\n            }\r\n            else {\r\n                if (dict['inverted'][val] === undefined) {\r\n                    dict['inverted'][val] = [prop];\r\n                }\r\n                else {\r\n                    dict['inverted'][val].push(prop);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    parseItemsCDN(data) {\r\n        let lines = data.split('\\n');\r\n\r\n        const items_game_cdn = {};\r\n\r\n        for (let line of lines) {\r\n            let kv = line.split('=');\r\n\r\n            if (kv[1]) {\r\n                items_game_cdn[kv[0]] = kv[1];\r\n            }\r\n        }\r\n\r\n        return items_game_cdn;\r\n    }\r\n\r\n    /**\r\n     * Downloads the given VPK files from the Steam CDN\r\n     * @param files Steam Manifest File Array\r\n     * @return {Promise<>} Fulfilled when completed downloading\r\n     */\r\n    async downloadFiles(files) {\r\n        const promises = [];\r\n\r\n        for (const file of files) {\r\n            let name = file.filename.split('\\\\');\r\n            name = name[name.length-1];\r\n\r\n            const path = `${this.config.directory}/${name}`;\r\n\r\n            const isDownloaded = await this.isFileDownloaded(path, file.sha_content);\r\n\r\n            if (isDownloaded) {\r\n                continue;\r\n            }\r\n\r\n            const promise = this.user.downloadFile(730, 731, file, `${this.config.directory}/${name}`);\r\n            promises.push(promise);\r\n        }\r\n\r\n        return Promise.all(promises);\r\n    }\r\n\r\n    /**\r\n     * Loads the CSGO dir VPK specified in the config\r\n     */\r\n    loadVPK() {\r\n        this.vpkDir = new vpk(this.config.directory + '/pak01_dir.vpk');\r\n        this.vpkDir.load();\r\n\r\n        this.vpkStickerFiles = this.vpkDir.files.filter((f) => f.startsWith('resource/flash/econ/stickers'));\r\n        this.vpkPatchFiles = this.vpkDir.files.filter((f) => f.startsWith('resource/flash/econ/patches'));\r\n    }\r\n\r\n    /**\r\n     * Given the CSGO VPK Directory, returns the necessary indices for the chosen options\r\n     * @param vpkDir CSGO VPK Directory\r\n     * @return {Array} Necessary Sticker VPK Indices\r\n     */\r\n    getRequiredVPKFiles(vpkDir) {\r\n        const requiredIndices = [];\r\n\r\n        const neededDirs = Object.keys(neededDirectories).filter((f) => !!this.config[f]).map((f) => neededDirectories[f]);\r\n\r\n        for (const fileName of vpkDir.files) {\r\n            for (const dir of neededDirs) {\r\n                if (fileName.startsWith(dir)) {\r\n                    const archiveIndex = vpkDir.tree[fileName].archiveIndex;\r\n\r\n                    if (!requiredIndices.includes(archiveIndex)) {\r\n                        requiredIndices.push(archiveIndex);\r\n                    }\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return requiredIndices.sort();\r\n    }\r\n\r\n    /**\r\n     * Downloads the required VPK files\r\n     * @param vpkDir CSGO VPK Directory\r\n     * @param manifestFiles Manifest files\r\n     * @return {Promise<void>}\r\n     */\r\n    async downloadVPKFiles(vpkDir, manifestFiles) {\r\n        this.log.debug('Computing required VPK files for selected packages');\r\n\r\n        const requiredIndices = this.getRequiredVPKFiles(vpkDir);\r\n\r\n        this.log.debug(`Required VPK files ${requiredIndices}`);\r\n\r\n        for (let index in requiredIndices) {\r\n            index = parseInt(index);\r\n\r\n            // pad to 3 zeroes\r\n            const archiveIndex = requiredIndices[index];\r\n            const paddedIndex = '0'.repeat(3-archiveIndex.toString().length) + archiveIndex;\r\n            const fileName = `pak01_${paddedIndex}.vpk`;\r\n\r\n            const file = manifestFiles.find((f) => f.filename.endsWith(fileName));\r\n            const filePath = `${this.config.directory}/${fileName}`;\r\n\r\n            const isDownloaded = await this.isFileDownloaded(filePath, file.sha_content);\r\n\r\n            if (isDownloaded) {\r\n                this.log.info(`Already downloaded ${filePath}`);\r\n                continue;\r\n            }\r\n\r\n            const status = `[${index+1}/${requiredIndices.length}]`;\r\n\r\n            this.log.info(`${status} Downloading ${fileName} - ${bytesToMB(file.size)} MB`);\r\n\r\n            await this.user.downloadFile(730, 731, file, filePath, (none, { type, bytesDownloaded, totalSizeBytes }) => {\r\n                if (type === 'progress') {\r\n                    this.log.info(`${status} ${(bytesDownloaded*100/totalSizeBytes).toFixed(2)}% - ${bytesToMB(bytesDownloaded)}/${bytesToMB(totalSizeBytes)} MB`);\r\n                }\r\n            });\r\n\r\n            this.log.info(`${status} Downloaded ${fileName}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns whether a file at the given path has the given sha1\r\n     * @param path File path\r\n     * @param sha1 File SHA1 hash\r\n     * @return {Promise<boolean>} Whether the file has the hash\r\n     */\r\n    async isFileDownloaded(path, sha1) {\r\n        try {\r\n            const hash = await hasha.fromFile(path, {algorithm: 'sha1'});\r\n\r\n            return hash === sha1;\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a VPK path, returns the CDN URL\r\n     * @param path VPK path\r\n     * @return {string|void} CDN URL\r\n     */\r\n    getPathURL(path) {\r\n        const file = this.vpkDir.getFile(path);\r\n\r\n        if (!file) {\r\n            this.log.error(`Failed to retrieve ${path} in VPK, do you have the package category enabled in options?`);\r\n            return;\r\n        }\r\n\r\n        const sha1 = hasha(file, {\r\n            'algorithm': 'sha1'\r\n        });\r\n\r\n        path = path.replace('resource/flash', 'icons');\r\n        path = path.replace('.png', `.${sha1}.png`);\r\n\r\n        return `https://steamcdn-a.akamaihd.net/apps/730/${path}`;\r\n    }\r\n\r\n    /**\r\n     * Returns the item Steam CDN URL for the specified name\r\n     *\r\n     * Example Sticker Names: cologne2016/nv, cologne2016/fntc_holo, cologne2016/fntc_foil, cluj2015/sig_olofmeister_gold\r\n     *\r\n     * You can find the sticker names from their relevant \"sticker_material\" fields in items_game.txt\r\n     *      items_game.txt can be found in the core game files of CS:GO or as itemsGame here\r\n     *\r\n     * @param name The item name (the sticker_material field in items_game.txt, or the cdn file format)\r\n     * @param large Whether to obtain the \"large\" CDN version of the item\r\n     * @return {string|void} If successful, the HTTPS CDN URL for the item\r\n     */\r\n    getStickerURL(name, large=true) {\r\n        if (!this.ready) {\r\n            return;\r\n        }\r\n\r\n        const fileName = large ? `${name}_large.png` : `${name}.png`;\r\n        const path = this.vpkStickerFiles.find((t) => t.endsWith(fileName));\r\n\r\n        if (path) return this.getPathURL(path);\r\n    }\r\n\r\n    /**\r\n     * Returns the item Steam CDN URL for the specified name\r\n     *\r\n     * Example Patch Names: case01/patch_phoenix, case01/patch_dangerzone, case01/patch_easypeasy, case_skillgroups/patch_goldnova1\r\n     *\r\n     * You can find the patch names from their relevant \"patch_material\" fields in items_game.txt\r\n     *      items_game.txt can be found in the core game files of CS:GO or as itemsGame here\r\n     *\r\n     * @param name The item name (the patch_material field in items_game.txt, or the cdn file format)\r\n     * @param large Whether to obtain the \"large\" CDN version of the item\r\n     * @return {string|void} If successful, the HTTPS CDN URL for the item\r\n     */\r\n     getPatchURL(name, large=true) {\r\n        if (!this.ready) {\r\n            return;\r\n        }\r\n\r\n        const fileName = large ? `${name}_large.png` : `${name}.png`;\r\n        const path = this.vpkPatchFiles.find((t) => t.endsWith(fileName));\r\n\r\n        if (path) return this.getPathURL(path);\r\n    }\r\n\r\n    /**\r\n     * Given the specified defindex and paintindex, returns the CDN URL\r\n     *\r\n     * The item properties can be found in items_game.txt\r\n     *\r\n     * @param defindex Item Definition Index (weapon type)\r\n     * @param paintindex Item Paint Index (skin type)\r\n     * @return {string|void} Weapon CDN URL\r\n     */\r\n    getWeaponURL(defindex, paintindex) {\r\n        if (!this.ready) return;\r\n\r\n        const paintKits = this.itemsGame.paint_kits;\r\n\r\n        // Get the skin name\r\n        let skinName = '';\r\n\r\n        if (paintindex in paintKits) {\r\n            skinName = paintKits[paintindex].name;\r\n\r\n            if (skinName === 'default') {\r\n                skinName = '';\r\n            }\r\n        }\r\n\r\n        // Get the weapon name\r\n        let weaponName;\r\n\r\n        const items = this.itemsGame.items;\r\n\r\n        if (defindex in items) {\r\n            weaponName = items[defindex].name;\r\n        }\r\n\r\n        // Get the image url\r\n        const cdnName = `${weaponName}_${skinName}`;\r\n\r\n        return this.itemsGameCDN[cdnName];\r\n    }\r\n\r\n    /**\r\n     * Returns whether the given name is a weapon by checking\r\n     * the prefab and whether it is used by one of the sides\r\n     * @param marketHashName Item name\r\n     * @return {boolean} Whether a weapon\r\n     */\r\n    isWeapon(marketHashName) {\r\n        const prefabs = this.itemsGame.prefabs;\r\n        const items = this.itemsGame.items;\r\n        const weaponName = marketHashName.split('|')[0].trim();\r\n\r\n        const weaponTags = this.csgoEnglish['inverted'][weaponName];\r\n\r\n        if (!weaponTags) return false;\r\n\r\n        // For every matching weapon tag...\r\n        for (const t of weaponTags) {\r\n            const weaponTag = `#${t}`;\r\n\r\n            const prefab = Object.keys(prefabs).find((n) => {\r\n                const fab = prefabs[n];\r\n\r\n                return fab.item_name === weaponTag;\r\n            });\r\n\r\n            let fab;\r\n\r\n            if (!prefab) {\r\n                // special knives aren't in the prefab (karambits, etc...)\r\n                const item = Object.keys(items).find((n) => {\r\n                    const i = items[n];\r\n\r\n                    return i.item_name === weaponTag;\r\n                });\r\n\r\n                fab = items[item];\r\n            }\r\n            else {\r\n                fab = prefabs[prefab];\r\n            }\r\n\r\n            if (fab && fab.used_by_classes) {\r\n                const used = fab.used_by_classes;\r\n\r\n                // Ensure that the item is used by one of the sides\r\n                if (used['terrorists'] || used['counter-terrorists']) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the sticker URL given the market hash name\r\n     * @param marketHashName Sticker name\r\n     * @return {string|void} Sticker image URL\r\n     */\r\n    getStickerNameURL(marketHashName) {\r\n        const reg = /Sticker \\| (.*)/;\r\n        const match = marketHashName.match(reg);\r\n\r\n        if (!match) return;\r\n\r\n        const stickerName = match[1];\r\n\r\n        for (const tag of this.csgoEnglish['inverted'][stickerName] || []) {\r\n            const stickerTag = `#${tag}`;\r\n\r\n            const stickerKits = this.itemsGame.sticker_kits;\r\n\r\n            const kitIndex = Object.keys(stickerKits).find((n) => {\r\n                const k = stickerKits[n];\r\n\r\n                return k.item_name === stickerTag;\r\n            });\r\n\r\n            const kit  = stickerKits[kitIndex];\r\n\r\n            if (!kit || !kit.sticker_material) continue;\r\n\r\n            const url = this.getStickerURL(stickerKits[kitIndex].sticker_material, true);\r\n\r\n            if (url) {\r\n                return url;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Returns the patch URL given the market hash name\r\n     * @param marketHashName Patch name\r\n     * @return {string|void} Patch image URL\r\n     */\r\n    getPatchNameURL(marketHashName) {\r\n        const reg = /Patch \\| (.*)/;\r\n        const match = marketHashName.match(reg);\r\n\r\n        if (!match) return;\r\n\r\n        const stickerName = match[1];\r\n\r\n        for (const tag of this.csgoEnglish['inverted'][stickerName] || []) {\r\n            const stickerTag = `#${tag}`;\r\n\r\n            const stickerKits = this.itemsGame.sticker_kits; // Patches are in the sticker_kits as well\r\n\r\n            const kitIndex = Object.keys(stickerKits).find((n) => {\r\n                const k = stickerKits[n];\r\n\r\n                return k.item_name === stickerTag;\r\n            });\r\n\r\n            const kit  = stickerKits[kitIndex];\r\n\r\n            if (!kit || !kit.patch_material) continue;\r\n\r\n            const url = this.getPatchURL(stickerKits[kitIndex].patch_material, true);\r\n\r\n            if (url) return url;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the graffiti URL given the market hash name\r\n     * @param marketHashName Graffiti name (optional tint)\r\n     * @param large Whether to obtain the \"large\" CDN version of the item\r\n     * @return {string|void} CDN Image URL\r\n     */\r\n    getGraffitiNameURL(marketHashName, large=true) {\r\n        const reg = /Sealed Graffiti \\| ([^(]*)/;\r\n        const match = marketHashName.match(reg);\r\n\r\n        if (!match) return;\r\n\r\n        const graffitiName = match[1].trim();\r\n\r\n        for (const tag of this.csgoEnglish['inverted'][graffitiName] || []) {\r\n            const stickerTag = `#${tag}`;\r\n\r\n            const stickerKits = this.itemsGame.sticker_kits;\r\n\r\n            const kitIndices = Object.keys(stickerKits).filter((n) => {\r\n                const k = stickerKits[n];\r\n\r\n                return k.item_name === stickerTag;\r\n            });\r\n\r\n            // prefer kit indices with \"graffiti\" in the name\r\n            kitIndices.sort((a, b) => {\r\n                const index1 = !!stickerKits[a].name && stickerKits[a].name.indexOf('graffiti');\r\n                const index2 = !!stickerKits[b].name && stickerKits[b].name.indexOf('graffiti');\r\n                if (index1 === index2) {\r\n                    return 0\r\n                } else if (index1 > -1) {\r\n                    return -1\r\n                } else {\r\n                    return 1\r\n                }\r\n            });\r\n\r\n            for (const kitIndex of kitIndices) {\r\n                const kit = stickerKits[kitIndex];\r\n\r\n                if (!kit || !kit.sticker_material) continue;\r\n\r\n                const url = this.getStickerURL(kit.sticker_material, true);\r\n\r\n                if (url) {\r\n                    return url;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the weapon URL given the market hash name\r\n     * @param marketHashName Weapon name\r\n     * @param {string?} phase Optional Doppler Phase from the phase enum\r\n     * @return {string|void} Weapon image URL\r\n     */\r\n    getWeaponNameURL(marketHashName, phase) {\r\n        const hasWear = wears.findIndex((n) => marketHashName.includes(n)) > -1;\r\n\r\n        if (hasWear) {\r\n            // remove it\r\n            marketHashName = marketHashName.replace(/\\([^)]*\\)$/, '');\r\n        }\r\n\r\n        const match = marketHashName.split('|').map((m) => m.trim());\r\n\r\n        const weaponName = match[0];\r\n        const skinName = match[1];\r\n\r\n        if (!weaponName) return;\r\n\r\n        const weaponTags = this.csgoEnglish['inverted'][weaponName] || [];\r\n        const prefabs = this.itemsGame.prefabs;\r\n        const items = this.itemsGame.items;\r\n\r\n        // For every matching weapon tag...\r\n        for (const t of weaponTags) {\r\n            const weaponTag = `#${t}`;\r\n\r\n            const prefab = Object.keys(prefabs).find((n) => {\r\n                const fab = prefabs[n];\r\n\r\n                return fab.item_name === weaponTag;\r\n            });\r\n\r\n            let weaponClass;\r\n\r\n            if (!prefab) {\r\n                // special knives aren't in the prefab (karambits, etc...)\r\n                const item = Object.keys(items).find((n) => {\r\n                    const i = items[n];\r\n\r\n                    return i.item_name === weaponTag;\r\n                });\r\n\r\n                if (items[item]) {\r\n                    weaponClass = items[item].name;\r\n                }\r\n            }\r\n            else {\r\n                const item = Object.keys(items).find((n) => {\r\n                    const i = items[n];\r\n\r\n                    return i.prefab === prefab;\r\n                });\r\n\r\n                if (items[item]) {\r\n                    weaponClass = items[item].name;\r\n                }\r\n            }\r\n\r\n            if (!weaponClass) continue;\r\n\r\n            // Check if this is a vanilla weapon\r\n            if (!skinName) {\r\n                if (weaponClass && this.itemsGameCDN[weaponClass]) {\r\n                    return this.itemsGameCDN[weaponClass];\r\n                }\r\n                else {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // For every matching skin name...\r\n            for (const key of this.csgoEnglish['inverted'][skinName] || []) {\r\n                const skinTag = `#${key.toLowerCase()}`;\r\n\r\n                const paintKits = this.itemsGame.paint_kits;\r\n\r\n                const paintindexes = Object.keys(paintKits).filter((n) => {\r\n                    const kit = paintKits[n];\r\n                    const isPhase = !phase || kit.name.endsWith(phase);\r\n\r\n                    return isPhase && kit.description_tag === skinTag;\r\n                });\r\n\r\n                // For every matching paint index...\r\n                for (const paintindex of paintindexes) {\r\n                    const paintKit = paintKits[paintindex].name;\r\n\r\n                    const path = (paintKit ? `${weaponClass}_${paintKit}` : weaponClass).toLowerCase();\r\n\r\n                    if (this.itemsGameCDN[path]) {\r\n                        return this.itemsGameCDN[path];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the music kit URL given the market hash name\r\n     * @param marketHashName Music kit name\r\n     * @return {string|void} Music kit image URL\r\n     */\r\n    getMusicKitNameURL(marketHashName) {\r\n        const reg = /Music Kit \\| (.*)/;\r\n        const match = marketHashName.match(reg);\r\n\r\n        if (!match) return;\r\n\r\n        const kitName = match[1];\r\n\r\n        for (const t of this.csgoEnglish['inverted'][kitName] || []) {\r\n            const tag = `#${t}`;\r\n\r\n            const musicDefs = this.itemsGame.music_definitions;\r\n\r\n            const kitIndex = Object.keys(musicDefs).find((n) => {\r\n                const k = musicDefs[n];\r\n\r\n                return k.loc_name === tag;\r\n            });\r\n\r\n            const kit = musicDefs[kitIndex];\r\n\r\n            if (!kit || !kit.image_inventory) continue;\r\n\r\n            const path = `resource/flash/${kit.image_inventory}.png`;\r\n\r\n            const url = this.getPathURL(path);\r\n\r\n            if (url) {\r\n                return url;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves the given item CDN URL given its market_hash_name\r\n     *\r\n     * Examples: M4A4 | 龍王 (Dragon King) (Field-Tested), Sticker | Robo, AWP | Redline (Field-Tested)\r\n     *\r\n     * Note: For a weapon, the name MUST have the associated wear\r\n     *\r\n     * @param marketHashName Item name\r\n     * @param {string?} phase Optional Doppler Phase from the phase enum\r\n     */\r\n    getItemNameURL(marketHashName, phase) {\r\n        marketHashName = marketHashName.trim();\r\n        let strippedMarketHashName = marketHashName;\r\n\r\n        // Weapons and Music Kits can have extra tags we need to ignore\r\n        const extraTags = ['★ ', 'StatTrak™ ', 'Souvenir '];\r\n\r\n        for (const tag of extraTags) {\r\n            if (strippedMarketHashName.startsWith(tag)) {\r\n                strippedMarketHashName = strippedMarketHashName.replace(tag, '');\r\n            }\r\n        }\r\n\r\n        if (this.isWeapon(strippedMarketHashName)) {\r\n            return this.getWeaponNameURL(strippedMarketHashName, phase);\r\n        }\r\n        else if (strippedMarketHashName.startsWith('Music Kit |')) {\r\n            return this.getMusicKitNameURL(strippedMarketHashName);\r\n        }\r\n        else if (marketHashName.startsWith('Sticker |')) {\r\n            return this.getStickerNameURL(marketHashName);\r\n        }\r\n        else if (marketHashName.startsWith('Sealed Graffiti |')) {\r\n            return this.getGraffitiNameURL(marketHashName);\r\n        }\r\n        else if (marketHashName.startsWith('Patch |')) {\r\n            return this.getPatchNameURL(marketHashName);\r\n        }\r\n        else {\r\n            // Other in items\r\n            for (const t of this.csgoEnglish['inverted'][marketHashName] || []) {\r\n                const tag = `#${t.toLowerCase()}`;\r\n                const items = this.itemsGame.items;\r\n                const prefabs = this.itemsGame.prefabs;\r\n\r\n                let item = Object.keys(items).find((n) => {\r\n                    const i = items[n];\r\n\r\n                    return i.item_name && i.item_name.toLowerCase() === tag;\r\n                });\r\n\r\n                let path;\r\n\r\n                if (!items[item] || !items[item].image_inventory) {\r\n                    // search the prefabs (ex. CS:GO Case Key)\r\n                    item = Object.keys(prefabs).find((n) => {\r\n                        const i = prefabs[n];\r\n\r\n                        return i.item_name && i.item_name.toLowerCase() === tag;\r\n                    });\r\n\r\n                    if (!prefabs[item] || !prefabs[item].image_inventory) continue;\r\n\r\n                    path = `resource/flash/${prefabs[item].image_inventory}.png`;\r\n                }\r\n                else {\r\n                    path = `resource/flash/${items[item].image_inventory}.png`;\r\n                }\r\n\r\n                const url = this.getPathURL(path);\r\n\r\n                if (url) {\r\n                    return url;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = CSGOCdn;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}